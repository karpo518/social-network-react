{"version":3,"file":"static/js/15.d812a855.chunk.js","mappings":"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","sources":["webpack://my-app/./src/components/Login/Login.module.css?3530","components/Login/LoginPage.tsx","webpack://my-app/./src/components/common/FormControls/FormControls.module.css?7a3d","components/common/FormControls/FormControls.tsx","utils/validators/validators.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"form\":\"Login_form__xawx9\",\"checkbox\":\"Login_checkbox__oyLjX\",\"checkboxWrap\":\"Login_checkboxWrap__1PPoj\",\"formControl\":\"Login_formControl__Yj7cj\",\"submit\":\"Login_submit__zALlr\",\"fieldContent\":\"Login_fieldContent__vK+x2\",\"errors\":\"Login_errors__c6sx5\"};","import { Button } from \"antd\";\nimport { FC } from \"react\";\nimport { useDispatch, useSelector } from \"react-redux\";\nimport { InjectedFormProps, reduxForm } from \"redux-form\";\nimport { ThunkDispatch } from \"redux-thunk\";\nimport { login, TAuthActions, updateCaptchaUrl } from \"../../redux/auth-reducer\";\nimport { TAppState } from \"../../redux/redux-store\";\nimport { required } from \"../../utils/validators/validators\";\nimport { createField, InputArea } from \"../common/FormControls/FormControls\";\nimport s from \"./Login.module.css\";\n\n\nexport const LoginPage: FC = () => {\n  \n  const captchaUrl = useSelector((state: TAppState) => state.auth.captchaUrl)\n  const isAuth = useSelector((state: TAppState) => state.auth.isAuth)\n\n  const dispatch = useDispatch<ThunkDispatch<TAppState, unknown, TAuthActions>>()\n\n  const onUpdateCaptchaUrl = () => {\n    dispatch(updateCaptchaUrl)\n  }\n\n  const onSubmit = (formData: TFormData) => {\n    dispatch(login(formData))\n  };\n\n  return (\n    <div>\n      <h1>Login</h1>\n      {isAuth ? (\n        <div>You are logged in already!</div>\n      ) : (\n        <LoginReduxForm captchaUrl={captchaUrl} onUpdateCaptchaUrl={onUpdateCaptchaUrl} onSubmit={onSubmit} />\n      )}\n    </div>\n  );\n};\n\nexport type TFormData = {\n  email: string\n  password: string\n  rememberMe: boolean\n  apiKey: string\n  captcha?: string\n}\n\ntype TOwnProps = {\n  captchaUrl: string | null\n  onUpdateCaptchaUrl: () => void\n  onSubmit: (formData: any) => void\n}\n\ntype TFormProps = TOwnProps & InjectedFormProps<TFormData,TOwnProps>\n\nconst LoginForm: FC<TFormProps> = (props) => {\n    \n  return (\n    <form onSubmit={props.handleSubmit} className={s.form}>\n\n      { createField<TFormData>('E-mail', 'email', [required], InputArea, {type: 'text', fieldType: 'input', autoComplete: 'on'}) }\n      { createField<TFormData>('Password', 'password', [required], InputArea, {type: 'password', fieldType: 'input', autoComplete: 'on'}) }\n      { createField<TFormData>('API key', 'apiKey', [required], InputArea, {type: 'text', fieldType: 'input', autoComplete: 'on'}) }\n\n      { \n        props.captchaUrl && \n        ( <div>\n            <div className={s.fieldContent}>\n                <img onClick={props.onUpdateCaptchaUrl} src={props.captchaUrl} alt={'captcha text'} />\n            </div>\n            <div className={s.fieldControl} >\n                { createField<TFormData>('Image text', 'captcha', [required], InputArea, {type: 'text', fieldType: 'input'}) }\n            </div>\n        </div> )\n      }\n      <div>\n\n        { createField<TFormData>(null, 'rememberMe', [], InputArea, {type: 'checkbox', fieldType: 'input', label: 'Remember me', 'id': 'rememberMe' }) }\n\n      </div>\n      {props.error && <div className={s.errors} > {props.error}</div>}\n      <div>\n        <Button type=\"primary\" htmlType=\"submit\" className={s.submit}>Login</Button>\n      </div>\n    </form>\n  );\n};\n\nconst LoginReduxForm = reduxForm<TFormData,TOwnProps>({ form: \"login\" })(LoginForm);\n","// extracted by mini-css-extract-plugin\nexport default {\"checkboxControl\":\"FormControls_checkboxControl__33VzZ\",\"formControl\":\"FormControls_formControl__Bze--\",\"error\":\"FormControls_error__rGNdT\",\"errorText\":\"FormControls_errorText__5Si0-\",\"fieldWrap\":\"FormControls_fieldWrap__e7QgK\",\"labelCheckboxWrap\":\"FormControls_labelCheckboxWrap__kXX0d\",\"labelTextWrap\":\"FormControls_labelTextWrap__nPV0n\"};","import { Checkbox, Input } from 'antd';\nimport TextArea from 'antd/lib/input/TextArea';\nimport { Component, FC } from 'react';\nimport { Field, WrappedFieldInputProps, WrappedFieldMetaProps } from \"redux-form\";\nimport { NestedKeyOf } from '../../../types/types';\nimport { FieldValidatorType } from \"../../../utils/validators/validators\";\nimport s from \"./FormControls.module.css\";\nimport { Field as FormikField, FieldProps } from \"formik\";\n\ntype PropsType = {\n  input: WrappedFieldInputProps\n  meta: WrappedFieldMetaProps\n  fieldType: string\n  id?: string\n  label?: string \n  type: 'textarea' | 'input' | 'checkbox' \n}\n\nexport const InputArea: FC<PropsType> = ({ input, meta: {touched, error}, fieldType, ...props }) => {\n  const hasError = touched && error;\n  return (\n    <div className={s.formControl + \" \" + (hasError ? s.error : \"\")}>\n      {props.label && props.type !== \"checkbox\" && (\n        <div className={`${s.labelTextWrap}`}>\n          <label htmlFor={props.id || \"\"}>{props.label}</label>\n        </div>\n      )}\n      \n      <div className={s.fieldWrap}>\n        {fieldType === \"input\" \n         ? props.type === \"checkbox\" \n              ? <Checkbox  {...input} {...props} >{props.label}</Checkbox> \n              : <Input {...input} {...props} />\n         : (\n          <TextArea {...input} {...props} />\n        )}\n      </div>\n\n      {hasError ? (\n        <div className={s.errorText}>\n          <span>{error}</span>\n        </div>\n      ) : (\n        \"\"\n      )}\n    </div>\n  );\n};\n\nexport function  createField<TFormData extends object>(\n  placeholder: string | null,\n  name: NestedKeyOf<TFormData>,\n  validators: Array<FieldValidatorType>,\n  component: string | Component<any,any,any> | FC<any>,\n  props: any\n)\n{\n  let wrapClasses = props.wrapClasses || \"\";\n\n  if (props.type && props.type === \"checkbox\") {\n    wrapClasses += s.checkboxControl;\n  }\n\n  return (\n    <div className={wrapClasses}>\n      <Field\n        placeholder={placeholder}\n        name={name}\n        validate={validators}\n        component={component}\n        {...props}\n      />\n    </div>\n  );\n};\n\ntype FormikPropsType = {\n  fieldType: string\n  id?: string\n  label?: string \n  type: 'textarea' | 'input' | 'checkbox' \n}\n\n\n\nexport const FormikInputArea: FC<FormikPropsType & FieldProps> = ({ field, form: {touched, errors}, fieldType, ...props }) => {\n  const hasError = touched[field.name] && errors[field.name]\n  return (\n    <div className={s.formControl + \" \" + (hasError ? s.error : \"\")}>\n      {props.label && props.type !== \"checkbox\" && (\n        <div className={`${s.labelTextWrap}`}>\n          <label htmlFor={props.id || \"\"}>{props.label}</label>\n        </div>\n      )}\n      \n      <div className={s.fieldWrap}>\n        {fieldType === \"input\" \n         ? props.type === \"checkbox\" \n              ? <Checkbox  {...field} {...props} >{props.label}</Checkbox> \n              : <Input {...field} {...props} />\n         : (\n          <TextArea {...field} {...props} />\n        )}\n      </div>\n\n      {touched[field.name] && errors[field.name] &&  (\n        <div className={s.errorText}>\n          <p>{ errors[field.name]?.toString() }</p>\n        </div>\n      )}\n    </div>\n  );\n};\n\n\nexport function  createFormikField<TFormData extends object>(\n  placeholder: string | null,\n  name: NestedKeyOf<TFormData>,\n  validators: Array<FieldValidatorType>,\n  component: string | Component<any,any,any> | FC<any>,\n  props: any\n)\n{\n  let wrapClasses = props.wrapClasses || \"\";\n\n  if (props.type && props.type === \"checkbox\") {\n    wrapClasses += s.checkboxControl;\n  }\n\n  return (\n    <div className={wrapClasses}>\n      <FormikField\n        placeholder={placeholder}\n        name={name}\n        validate={validators}\n        component={component}\n        {...props}\n      />\n    </div>\n  );\n};","export type FieldValidatorType = (field: string) => string | undefined\n\nexport const required: FieldValidatorType = (value: string): string | undefined => {\n    if(value && value !== '') {\n        return undefined\n    }\n\n    return 'It is required field!'\n}\n\nexport const maxLength = (maxLengthValue: number): FieldValidatorType => {\n    return (value) => {\n        if(value && value.length > maxLengthValue) {\n            return `You have exceeded the maximum message length(${maxLengthValue})`\n        }\n        \n        return undefined\n    }\n}"],"names":["LoginPage","captchaUrl","useSelector","state","auth","isAuth","dispatch","useDispatch","LoginReduxForm","onUpdateCaptchaUrl","updateCaptchaUrl","onSubmit","formData","login","reduxForm","form","props","handleSubmit","className","s","createField","required","InputArea","type","fieldType","autoComplete","onClick","src","alt","label","error","htmlType","input","meta","touched","hasError","htmlFor","id","TextArea","placeholder","name","validators","component","wrapClasses","Field","validate","FormikInputArea","field","errors","toString","createFormikField","value","maxLength","maxLengthValue","length"],"sourceRoot":""}